package duoTai;

/**
 * @姓名 李明
 * @日期 2018�?11�?5日上�?7:37:12
 * 
 *     面向对象编程有三大特性：封装、继承�?�多态�??
 * 
 *     封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据�?�对外界而已它的内部细节是隐藏的�?
 *     暴露给外界的只是它的访问方法�?
 * 
 *     继承是为了重用父类代码�?�两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多�?�做了铺垫�?�那么什么是多�?�呢�?
 *     多�?�的实现机制又是�?么？请看我一�?为你揭开�?
 * 
 *     �?谓多态就是指程序中定义的引用变量�?指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，�?�是在程序运行期间才确定�?
 *     即一个引用变量�?�底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定�??
 *     因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从�?�导致该引用调用�?
 *     具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以�?�择多个运行状�?�，这就是多态�?��??
 * 
 *           
 *     比如你是�?个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之
 *     后才能够猜出来是何种酒�?�你�?喝，这是剑南春�?�再喝这是五粮液、再喝这是酒鬼酒�?.在这里我们可以描述成如下�?
 * 
 *            �? a = 剑南�?
 * 
 *            �? b = 五粮�?
 * 
 *            �? c = 酒鬼�?
 * 
 *            �?
 *           
 *     这里�?表现的的就是多�?��?�剑南春、五粮液、酒鬼酒都是酒的子类，我们只是�?�过酒这�?个父类就能够引用不同的子类，这就是多态�?��??
 *     我们只有在运行的时�?�才会知道引用变量所指向的具体实例对象�??
 *           
 *     诚然，要理解多�?�我们就必须要明白什么是“向上转型�?��?�在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中�?
 *     酒（Win）是父类，剑南春（JNC）�?�五粮液（WLY）�?�酒鬼酒（JGJ）是子类。我们定义如下代码：
 * 
 *            JNC a = new JNC();
 * 
 *            对于这个代码我们非常容易理解无非就是实例化了�?个剑南春的对象嘛！但是这样呢�?
 * 
 *            Wine a = new JNC();
 * 
 *    在这里我们这样理解，这里定义了一个Wine类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine�?
 *    �?以a是可以指向JNC实例对象的�?�这样做存在�?个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能�?
 *    如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能�??
 * 
 *     但是向上转型存在�?些缺憾，那就是它必定会导致一些方法和属�?�的丢失，�?�导致我们不能够获取它们。所以父类类型的引用可以调用父类
 *     中定义的�?有属性和方法，对于只存在与子类中的方法和属�?�它就望尘莫及了�?
 */
 class Wine {
    public void fun1(){
        System.out.println("Wine 的Fun.....");
        fun2();
    }
    
    public void fun2(){
        System.out.println("Wine 的Fun2...");
    }
}
 
 class JNC extends Wine{
    /**
     * @desc 子类重写父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法�?
     * @param a
     * @return void
     */
    public void fun1(String a){
        System.out.println("JNC �? Fun1...");
        fun2();
    }
    
    /**
     * 子类重写父类方法
     * 指向子类的父类引用调用fun2时，必定是调用该方法
     */
    
    public void fun2(){
        System.out.println("JNC 的Fun2...");
    }
}
 
 class Test {
    public static void main(String[] args) {
        Wine a = new JNC();
        a.fun1();
    }
}
/**
 * Output: Wine 的Fun..... JNC 的Fun2...
 * 
 *   从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()�?
 * 
 *  分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，�?�且重载后的fun1(String a)�?
 * fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String
 * a)方法。�?�子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法�?
 * 
 *       �?以对于多态我们可以�?�结如下�?
 * 
 *       指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法�?
 * 该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时�?�，必定是使用子类中定义的这些方�?
 * （动态连接�?�动态调用）�?
 * 
 *       对于面向对象而已，多态分为编译时多�?�和运行时多态�?�其中编辑时多�?�是静�?�的，主要是指方法的重载，它是根据参数列表的不同
 * 来区分不同的函数，�?�过编辑之后会变成两个不同的函数，在运行时谈不上多�?��?��?�运行时多�?�是动�?�的，它是�?�过动�?�绑定来实现的，
 * 也就是我们所说的多�?��??
 * 
 */
